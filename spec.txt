最小AEC3(C++)の仕様書（再実装用）

目的
- 16 kHz モノラル固定・64サンプルのブロック処理で動作する、教育用の最小エコーキャンセラー（AEC3）の仕様を定義する。
- ここに記す仕様は本リポジトリの実装（ヘッダ主体）に対応し、同等の挙動を再実装可能な粒度で示す。

設計の前提・範囲
- 対象: macOS/Apple Silicon 前提、単一プロセス・単一スレッド。
- サンプリング周波数: 16 kHz 固定。
- チャネル: モノラル固定（1ch）。
- フレーム/ブロック: 64 サンプル/ブロック（= 4 ms）。
- FFT: 実数128点（時間窓64＋オーバーラップ64）。
- 窓: sqrt-Hanning による解析・合成一貫の OLA（Overlap-Add）。
- 構成: 遅延推定（MatchedFilter）→ レンダ整列 → 線形減算（周波数領域の分割畳み込み適応FIR）→ スペクトル抑圧（残留エコー推定＋ゲイン設計）→ OLA 合成。
- 省略: マルチバンド、マルチチャネル、AGC、ノイズサプレッサ、ダブルトーク高度判定などは対象外。

公開API（最上位）
- 型: `EchoCanceller3`
  - `void AnalyzeRender(const AudioBuffer& render)`
    - 引数 `render`: 64サンプルのモノラルブロック。内部キューへ蓄積。
  - `void ProcessCapture(AudioBuffer* capture)`
    - 内部に貯めた `render` ブロックを処理系へ流し込み、`capture` の64サンプルをエコー抑圧して上書きする。
  - `void SetProcessingModes(bool enable_linear_filter, bool enable_nonlinear_suppressor)`
    - 線形減算・非線形抑圧の有効/無効を切替。
- 使用順序: ブロック単位で「AnalyzeRender(render) → ProcessCapture(capture)」を随時反復。

入出力データ型
- `AudioBuffer`
  - 内部に `std::vector<float> data_`（長さ64）。
  - `CopyFrom(const int16_t*)` でPCM16→floatへコピー、`CopyTo(int16_t*)` でクリッピング・丸め付きでfloat→PCM16へ戻す。
- `Block`
  - 内部に `std::array<float, 64> data_`。`View()` で `std::span<float,64>` を取得。

定数と時間構造
- `kNumBlocksPerSecond = 250`（= 16,000 Hz / 64）。
- FFT 関連:
  - `kFftLength = 128`、`kFftLengthBy2 = 64`、`kFftLengthBy2Plus1 = 65`。
  - 解析: 直前64サンプル×sqrt-Hanning（後半）＋現在64サンプル×sqrt-Hanning（前半）を連結し128点FFT。
  - 合成: 抑圧後の複素スペクトルを128点逆FFT→ OLA（旧後半×sqrt-Hanning後半＋新前半×sqrt-Hanning前半）。

全体処理フロー（1ブロックの概念）
1) Render取り込み: `EchoCanceller3::AnalyzeRender(render)` で `Block` へコピーし内部キューへpush（サイズ上限100）。
2) Renderバッファ転送: `ProcessCapture` 頭でキューを空にするまで `BlockProcessor::BufferRender` へ送る。
3) 遅延処理準備: `RenderDelayBuffer::PrepareCaptureProcessing()` がオーバ/アンダーランを検知し、必要なら遅延推定器をリセット。
4) 遅延推定: `EchoPathDelayEstimator::EstimateDelay(ds_render, capture)`
   - captureを4:1ダウンサンプリング（平均）→ MatchedFilter更新→ ヒストグラム集計で安定ラグのみ採用。
   - 得られた遅延（サンプル）をブロック数へ変換（>> 6）。
5) 整列: `RenderDelayBuffer::AlignFromDelay(estimated_delay_blocks)` でリングバッファのread/writeを再配置。
6) エコー除去: `EchoRemover::ProcessCapture`
   - 線形減算（有効時）→ 残留・近端のスペクトル計算→ 残留エコー推定→ 抑圧ゲイン→ OLA 合成。
7) 出力: 時間領域64サンプルで `AudioBuffer` へ上書き。

遅延推定（EchoPathDelayEstimator）
- ダウンサンプル係数: 4（`DecimateBy4` = 4点平均）。
- MatchedFilter
  - フィルタ本数: 5（`kNumFilters`）。
  - サブブロック長: 16 サンプル（64/4）。
  - 窓長: 32 サブブロック（512 サンプル@DS後）。
  - 隣接ラグ間隔: 24 サブブロック（= 32 の 3/4）。
  - 最大ラグ: 5*24 + 32 = 152 サブブロック。
  - 更新: 逐次最小二乗に類似の形で、エネルギーが十分（x2_sum > 窓長×150^2）な場合のみ平滑係数 `kSmoothing=0.7` で係数更新。
  - 信頼判定: 誤差和がアンカー（入力パワー）の `kMatchingFilterThreshold=0.2` 倍未満、かつ端から離れたピークのみ採用。
- ラグ集約（MatchedFilterLagAggregator）
  - ヒストグラム長: `kMaxFilterLag + 1`。
  - ヘッドルーム: 8（サンプル@DS後）だけ手前にシフトして登録。
  - 採用条件: 直近履歴の最多ビンのカウントが `initial=5` を超えるか、いちど `converged=20` を超えた候補が再度最多となった場合。
  - 出力: サンプル数（DS後）。返値<0は未確定。
- 出力変換: DS後サンプル→ 元サンプルへ×4→ ブロック数へ `>> 6`（=64で除算）。

レンダ整列（RenderDelayBuffer）
- リングバッファ構成（ブロック領域・FFT領域・スペクトル領域を並走）:
  - `downsampling_factor=4`、`num_filters=5`、`filter_length_blocks=13`。
  - 下位レートのバッファ長 `GetDownSampledBufferSize = 16 * (24*5 + 32 + 1) = 2448` サンプル。
  - レンダディレイバッファ長 `GetRenderDelayBufferSize = 2448/16 + 13 + 1 = 167` ブロック（=FFT/スペクトルも同数）。
- Insert(block):
  - `Block` を保存、DS（平均）して低レートリングへ逆順書き込み、Padded FFT→ スペクトル保存。
  - 低レートやブロックの read==write でオーバーラン検知→ `Reset()`（遅延初期化・整列やり直し）。
- PrepareCaptureProcessing():
  - キャプチャ側の読出しを1ステップ進める。低レート read==write ならアンダーラン扱い（推定器リセット）。
- AlignFromDelay(delay_blocks):
  - バッファレイテンシ `BufferLatency()` と外部遅延ブロックを合算→ 読み書き位置を再配置。
  - 実変更があれば `true`（上位は「遅延変化イベント」として扱う）。

線形減算器（Subtractor）
- Partitioned Frequency-Domain Adaptive FIR（FDL/NLMS系）。
- フィルタ長: `kFilterLengthBlocks = 13` パーティション。
  - 有効インパルス長 ≒ 13 × 64 = 832 サンプル。
- 出力生成:
  - レンダの複素スペクトルリング `X_p` と係数 `H_p` を周波数毎に複素乗算・和（p=0..P-1）→ `S`。
  - 128点IFFT→ 最後の64点をスケール `1/kFftLengthBy2` して線形予測 `s[n]`。
  - 誤差 `e[n] = y[n] - s[n]`。
- メトリクス:
  - ブロック毎に `y2 = Σ y[n]^2`、`e2 = Σ e[n]^2`。
- スペクトル:
  - `e` をゼロ詰め窓で 128点FFT→ `E` とパワー `E2`。

フィルタ更新（FilterUpdateGain）
- 目的: `G = μ · E` を計算（周波数領域の勾配）。
- 入力: レンダパワー `X2`（直近P個のスペクトルの和）、誤差信号 `E/E2`、フィルタ応答の擬似ERL `erl`。
- 逐次:
  - コールカウンタと「励起不足」カウンタでウォームアップ（Pブロック）中は `G=0`。
  - 雑音ゲート: `X2[k] < kNoiseGate(= 20075344.f)` の帯域は `μ=0`。
  - ステップサイズ: `μ[k] = H_err[k] / (0.5*H_err[k]*X2[k] + P*E2[k])`。
  - 誤差状態更新: 収束目安 `e2 <= 0.5*y2` なら `H_err += kLeakageConverged*erl`、さもなくば `kLeakageDiverged*erl`。`H_err` は `[kErrorFloor, kErrorCeil] = [0.001, 2]` にクランプ。
- 係数更新: `H_p ← H_p + X_p ⊗ G`（パーティションごとに複素畳み込みに相当する更新）。
- 係数制約: 各パーティションを時間領域へ戻し、前半64サンプル以外をゼロ化→ FFTで戻す（循環的に1パーティションずつ）。

AdaptiveFirFilter（周波数領域適応FIR）の具体仕様
- 目的: レンダ信号の周波数領域リングバッファ `X_p` とパーティション係数 `H_p` を用いて、分割畳み込みにより線形エコー推定 `s[n]` を生成し、勾配 `G` に基づいて `H_p` を更新する。
- 構成
  - パーティション数: `P = size_partitions`（本実装では `P=13`）。
  - 係数表現: 各パーティションは複素スペクトル `H_p[k] = Hr + j·Hi`（`k = 0..64`）。配列は `FftData`（re/im各65）で保持。
  - レンダFFTリング: `render_buffer.GetFftBuffer()` が `X[k]` のリング（`FftData`列）を返す。現在の読み位置 `idx = render_buffer.Position()` を起点に `p=0..P-1` で順に参照（ラップあり）。
- フィルタ出力（ApplyFilter / Filter）
  - 周波数領域で合成: `S[k] = Σ_{p=0..P-1} X_p[k] · H_p[k]`。
    - 複素乗算: `S.re += X.re*H.re − X.im*H.im`、`S.im += X.re*H.im + X.im*H.re`。
  - 128点IFFT→ 時間領域128点。最後の64点を `1/64` でスケールしたものが線形予測 `s[n]`（n=0..63）。
- 係数更新（Adapt）
  - 勾配FFT `G[k]` は `FilterUpdateGain` が生成（NLMS系）。
  - 各パーティションの更新式（全k）:
    - `H_p[k] ← H_p[k] + conj(X_p[k]) · G[k]`。
    - 実装の実数式: 
      - `Hr += X.re*G.re + X.im*G.im`
      - `Hi += X.re*G.im − X.im*G.re`（= conj(X)*G の虚部）
  - 更新後に制約（Constrain）を適用。
- 係数制約（Constrain）
  - ラウンドロビンで1パーティションを選び、時間領域へ戻して整形:
    1) `h_p = IFFT(H_p)`（128点）。
    2) 正規化: 前半64サンプルを `1/64` 倍。
    3) 後半64サンプルを 0 にする（循環畳み込み成分の切り落とし）。
    4) `H_p = FFT(h_p)` に戻す。
  - 効果: インパルス応答の実長を64サンプルに制限し、パーティション法の前提（線形畳み込み）を保つ。
- 応答の可視化用スペクトル（ComputeFrequencyResponse/ComputeErl）
  - `ComputeFrequencyResponse`: 各 `p`・各 `k` で `H2[p][k] = |H_p[k]|^2` を計算。
  - `ComputeErl`: `erl[k] = Σ_p H2[p][k]`（パーティション和）。`FilterUpdateGain` 内のリーク更新に使用。
- リセット
  - `HandleEchoPathChange()`: 全 `H_p` を 0 で初期化（エコーパス変更に追従）。
- 実装上の取り決め
  - DC/Nyquist の虚部は実数FFTの性質上 0 を保つことが望ましい（制約処理で自然に保たれる）。
  - `render_buffer.Position()` はレンダ整列（`AlignFromDelay`）済みの読み位置を返し、`X_p` の選択はこの位置から `p` 方向に前進する。
  - 数値安定: 更新の大小は `FilterUpdateGain` 側のゲート・リーク・H_errの境界で制御する前提。

状態管理とERLE（AecState, ErleEstimator, SubtractorOutputAnalyzer）
- `SubtractorOutputAnalyzer`
  - 収束判定: `e2 < 0.5*y2` かつ `y2 > 50^2 * 64`（= 160,000）で収束フラグ。
- `FilteringQualityAnalyzer`
  - `overall_usable_linear_estimates_` 条件:
    - 活性レンダ（レベル閾値超え）下での更新ブロック数が、起動から 0.4 秒超・直近リセットから 0.2 秒超。
    - かつ、一度でも収束が観測されている。
  - これが `true` の間は「線形推定は有用」と見なす。
- `ErleEstimator(startup_phase_length_blocks = 2 秒)`
  - 起動直後 2 秒は更新しない。以後、帯域毎に `ERLE[k] = clamp(Y2[k]/max(E2[k],1e-6), [1, 64])`。

残留エコー推定（ResidualEchoEstimator）
- 直近レンダの定常雑音床 `X2_noise_floor` を追従（最小値保持＋一定保持時間後に上方更新）。
- 線形有用時: `R2 = S2_linear / ERLE`。
- 非線形時: レンダスペクトルの「最大包絡」をフィルタ遅延の前後ウィンドウで集約→ 雑音ゲート（`kNoiseGatePower=27509.42` と傾斜0.3）→ 雑音床差し引き（勾配10）→ 0以上でクリップ→ `R2 = X2 * echo_path_gain(=1.0)`。

抑圧ゲイン設計（SuppressionGain）
- 近端スペクトル: `nearend = MA(4フレーム)`（移動平均）。
- 可聴重み: `residual_echo` を帯域ごとの可聴しきいでソフトゲート（低/中/高で閾値は固定）。
- `GainToNoAudibleEcho(nearend, echo)` で帯域プロファイルに沿った無可聴エコー条件から基準ゲイン `G` を計算。
- 最小/最大ゲイン拘束:
  - `GetMinGain(weighted_echo, last_nearend, last_echo)` により主に低域での急激すぎる減衰を抑制（`kMaxDecFactorLf = 0.25`）。
  - `GetMaxGain(last_gain)` により上昇スルーレートを制限（`kMaxIncFactor = 2.0`）。
- 帯域整形: 超低域の不正抑圧を補正（0/1番目を2番目以下に制限）、高域は2 kHz 相当以上を同一上限へクリップ、Nyquist帯の鏡像整合。
- 最後に `sqrt` を取り、パワーゲイン→振幅ゲインへ変換。

抑圧フィルタ（SuppressionFilter + OLA）
- 線形が有用な間は `E`（減算器出力のFFT）に対してゲイン適用、そうでない間は `Y`（元のキャプチャFFT）へ適用。
- ゲイン適用後に 128点IFFT →
  - 旧ブロック後半の保存バッファと新ブロック前半を sqrt-Hanning で重畳 → 出力64サンプルを正規化（`2/kFftLength`）。
  - 出力は16-bit相当レンジへクリップ（[-32768, 32767]）。

モード切替
- `enable_linear_filter = false` の場合:
  - 減算器は実行せず `e := y` とみなす。メトリクスは `e=y` 前提で計算。
  - 非線形のみを通して出力。
- `enable_nonlinear_suppressor = false` の場合:
  - 線形のみ（`e` をそのまま時間領域へ直出力）。
- 両方 false の場合:
  - 完全素通し。

数値・窓・FFTレイアウト要件
- 解析窓/合成窓: 仕様内の `kSqrtHanning128[128]` を使用。
- FFTレイアウト: OouraFFT の packed 形式に準拠（re[0], re[N/2], re[1], im[1], re[2], im[2], ...）。`FftData` が相互変換を保持。
- スケーリング: 減算器のIFFT後の時間領域は `1/kFftLengthBy2`、OLA出力は `2/kFftLength`。

バッファとメモリ
- `RenderDelayBuffer` 内部:
  - `BlockBuffer(167)`, `SpectrumBuffer(167)`, `FftBuffer(167)`、低レート `DownsampledRenderBuffer(2448)`。
  - 既定整列は `Reset()` で遅延10ブロック相当。
- `EchoCanceller3` の内部レンダキュー: `std::deque<Block>`、最大100ブロック、溢れたら古いものを捨てる。

例外・リセット条件
- レンダ・キャプチャの順序や遅延が破綻（オーバ/アンダーラン）したときは、遅延推定とリング読出し位置をリセット。
- 遅延推定が新規に確定したら `AlignFromDelay` を実行。変更があったブロックのみ「遅延変化イベント」。
- 既知の遅延変化（BufferFlush / NewDetectedDelay）では、線形フィルタ係数や推定器状態をリセット。

I/O使用例（参照）
- オフライン（`cancel_file.cc`）:
  - 2つの16k/mono WAV（render x, capture y）をブロックに分割して `AnalyzeRender(x) → ProcessCapture(y)` を繰返し、処理結果を `processed.wav` に保存。
- リアルタイム（`echoback.cc`）:
  - PortAudio コールバックで 64 サンプルずつ取り回し。直近の出力ブロックをレンダ参照として `AnalyzeRender` に与え、`ProcessCapture` の結果を再生キューへ積む。遅延推定の変化と1秒平均のキャンセル量（ERLE近似dB）をログ出力。

再実装のための擬似コード（主要部）
- EchoCanceller3::ProcessCapture
  - while (render_q非空) { render = pop(); block_processor.BufferRender(render); }
  - cap_block ← capture をコピー
  - block_processor.ProcessCapture(&cap_block)
  - capture ← cap_block を書き戻し

- BlockProcessor::ProcessCapture
  - if (!render_started) return
  - event = render_buffer.PrepareCaptureProcessing(); if (event==Underrun) delay_estimator.Reset()
  - d = delay_estimator.EstimateDelay(ds_render, capture)
  - if (d>=0) changed = render_buffer.AlignFromDelay(d>>6); if (changed) variability=kNewDetectedDelay
  - echo_remover.ProcessCapture(variability, render_buffer.GetRenderBuffer(), capture)

- Subtractor::Process
  - X2 = render_buffer.SpectralSum(P)
  - S = ApplyFilter(render_buffer, H)
  - e = y - IFFT(S).last64_scaled
  - E = FFT_zero_padded(e); E2 = |E|^2
  - G = UpdateGain(X2, E/E2, erl, P)
  - H = Adapt(H, render_buffer, G); Constrain(H)

- EchoRemover::ProcessCapture
  - if (variability.DelayChanged()) { subtractor.HandleEchoPathChange(); aec_state.HandleEchoPathChange(); }
  - if (!linear && !nonlinear) return
  - if (linear) { subtractor.Process(..., &out); e = out.e } else { e = y; out.ComputeMetrics(y) }
  - Y = PaddedFFT(y), E = PaddedFFT(e), S2_linear = |Y−E|^2, Y2=|Y|^2, E2=|E|^2
  - aec_state.Update(render, E2, Y2, out)
  - R2 = residual_echo_estimator.Estimate(aec_state, render, S2_linear, Y2)
  - near = (linear usable) ? E2 : Y2; echo = (linear usable) ? S2_linear : R2
  - G = suppression_gain.GetGain(near, echo, R2)
  - ApplyGain(G, (linear usable ? E : Y)) → y  // OLA

主要パラメータ一覧（実装値）
- ブロック: 64 サンプル、1ブロック=4 ms、1秒=250ブロック。
- MatchedFilter: `kSmoothing=0.7`、閾値 `kMatchingFilterThreshold=0.2`、励起上限 150。
- ラグ集約: 初期5・収束20、ヘッドルーム8（DS後サンプル）。
- 線形フィルタ長: 13 パーティション（有効832サンプル）。
- フィルタ更新: `kLeakageConverged=5e-5`、`kLeakageDiverged=5e-2`、`kErrorFloor=1e-3`、`kErrorCeil=2`、`kNoiseGate=20075344`、`H_error_initial=10000`。
- ERLE: 上限64、起動2秒は更新停止。
- 残留エコー推定: `kNoiseFloorHold=50`、`kMinNoiseFloorPower=1638400`、`kStationaryGateSlope=10`、`kNoiseGatePower=27509.42`、`kNoiseGateSlope=0.3`、前後ウィンドウ=各1フレーム。
- 抑圧ゲイン: `kMaxIncFactor=2.0`、`kMaxDecFactorLf=0.25`、近端平滑=4フレーム。
- OLA正規化: 減算器IFFT後 `1/64`、合成後 `2/128`。
- リングサイズ: レンダディレイ 167 ブロック、DSバッファ 2448 サンプル。

実装上の注意
- すべて float（単精度）で処理。I/Oの16-bit変換時のみクリップと丸め。
- `std::span`（C++20）や `std::array` を用いた固定長・借用参照を多用。
- スレッド安全性は考慮しない（単一コールバックスレッド想定）。
- 例外/エラー処理は最小限。オーバ/アンダーラン時はハードリセット。

この仕様の意図
- AECの学習用として、(1) 遅延推定、(2) 線形適応、(3) 残留抑圧、(4) OLA 合成の最短経路を示す。
- 係数や閾値は教育目的で大胆に単純化・固定化している。最良の音質よりも仕組みの理解を優先する。

線形/非線形の整理（要約）
- 非線形処理の位置付け: 時間領域FIRではなく、周波数毎の振幅ゲイン `G[k]` を設計して適用するスペクトル抑圧（post-filter）。線形減算で取り切れない残留エコーを減衰させる。
- 入力FFT: `Y`（マイク）と `E`（線形減算後）。`Y2=|Y|^2`, `E2=|E|^2`。線形が使えない場合は `E:=Y` とする。
- 線形エコーパワー: `S2_linear = |Y−E|^2`。
- 状態/残留推定: 収束時は `R2=S2_linear/ERLE`、非収束時はレンダ側の「エコー生成パワー」を局所最大＋ゲート＋雑音床差し引きで見積る。
- ゲイン設計: `nearend`（`E2`または`Y2`の4フレーム移動平均）と `R2` の帯域比から、無可聴エコーを狙う `G[k]` を算出。上昇/下降のスルーレート制限、低/高域の帯域整形を行い、最後に `sqrt` でパワー→振幅へ変換。
- 合成: `G` を（線形有用なら `E` に、非有用なら `Y` に）乗算し、128点IFFT＋sqrt-HanningのOLAで64サンプルへ再構成。
- 非線形たる理由: `G[k]` は信号依存・時間変動・帯域別で変わるため LTI（線形時不変）ではない。
- 線形無効モード: 減算器は実行せず `e:=y` とみなし、残留推定＋周波数マスクだけで動作。

一般性（よくある実装か）
- アーキテクチャの一般性: 「遅延推定（MatchedFilter）→ 周波数領域の分割畳み込み適応FIR（線形）→ スペクトル抑圧ポストフィルタ（非線形）→ OLA 合成」はAECの定番構成であり、本仕様はこの“教科書的”流れに沿う。
- 本実装の簡略点:
  - 多くのパラメータを固定（自動最適化や環境推定は最小限）。
  - ダブルトーク等の厳密判定・コヒーレンス指標を省略。
  - 単一帯域・16k固定・64サンプル固定の単純化。
  - 可聴性重み付けは簡易（高度な聴覚モデルやCNGは未実装）。
  - 非収束時の残留推定は「最大包絡＋ゲート＋雑音床差し引き」の素朴な形。
- 備考: 歴史的NLP（センタークリッパ等）の時間領域非線形より、近年は本仕様のような周波数マスク型ポストフィルタが主流。
